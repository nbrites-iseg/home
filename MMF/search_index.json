[["index.html", "Mathematical Methods in Finance Lecture notes (part II) Preface", " Mathematical Methods in Finance Lecture notes (part II) Nuno M. Brites 2024/2025 Preface This module aims to review basic concepts about mathematical models in finance in order to enable students from various backgrounds (exact sciences and social sciences) to apply techniques in mathematical finance. It is also expected to provide students with a conceptual understanding of the models and techniques used in financial mathematics. Finally, students are expected to acquire knowledge of option pricing models. All errors and omissions are entirely my responsibility. Please notify me if you find any errors or typos. Suggestions and feedback are also welcome. Have a happy and successful year!   Copyright: All rights reserved. No parts of the content of this website may be reproduced or distributed without the prior written permission of the author. Without prior written permission, it is not permitted to copy, download or reproduce the text, code, and images in any way whatsoever. 2024 \\(|\\) Nuno M. Brites \\(|\\) nbrites@iseg.ulisboa.pt   "],["r-and-rstudio.html", "1 R and RStudio 1.1 About R and RStudio 1.2 Installing R and RStudio 1.3 The prompt 1.4 Assignments 1.5 Rules for defining variables", " 1 R and RStudio 1.1 About R and RStudio R is a free software for statistical (but not only!) computing and graphics. R is an integrated suite of software facilities for data manipulation, calculation and graphical display. It includes: an effective data handling and storage facility; a suite of operators for calculations on arrays, in particular matrices; a large, coherent, integrated collection of intermediate tools for data analysis; graphical facilities for data analysis and display either on-screen or on hardcopy; well-developed, simple and effective programming language which includes conditionals, loops, user-defined recursive functions and input and output facilities. 1.2 Installing R and RStudio Go to https://cran.r-project.org/ - this site will offer you all necessary information on R and its packages. Download R for Windows or MacOS to install the base distribution. Install R. Go to https://rstudio.com/products/rstudio/ - this site will offer you all necessary information on RStudio. Download RStudio for Windows or MacOS to install the desktop distribution. Install RStudio. 1.3 The prompt R has a command line interface, and will accept simple commands to it. This is marked by a \\(&gt;\\) symbol, called the prompt. If you type a command and press return, R will evaluate it and print the result for you. Try now! Write &gt; print(&quot;My first R command!&quot;) ## [1] &quot;My first R command!&quot; Lines starting with # are ignored by R and can be used to insert comments in the script. 1.4 Assignments The expression x &lt;- 1 creates a called x and assigns the value 1 to x. Note that the variable on the left is assigned to the value on the right. The left hand side must contain only a single variable name. To get the “&lt;-” write the “&lt;” sign and the “-” sign: “x &lt;- 1”. It is possible (actually is a good idea) to leave spaces between the variable name and its value, but it is not possible to have a space between the \\(&lt;\\) and \\(-\\) signs! One can also assign with = (or -&gt;). However, in order to avoid confusion, it is common to use &lt;- to distinguish from the equality operator =. 1.5 Rules for defining variables Names of variables can be chosen quite freely in R. They can be built from letters, digits, the period (dot) symbol and the underscore symbol (_). However, one should pay attention to: do not start a name with a digit or a period followed by a digit; R is case sensitive, so “A” and “a” refer to different variables; be consistent with variables names throughout the program; avoid names that provide no description, e.g., single-letter names, unless if they are parameters; some names are already used by the system, e.g., FALSE, TRUE, exp, sum, etc. "],["r-basics.html", "2 R basics 2.1 Basic operations 2.2 Precision 2.3 Infinity or not defined, and missings 2.4 Important commands 2.5 Internal help function", " 2 R basics 2.1 Basic operations &gt; 2 + 2 ## [1] 4 &gt; &gt; 7 * 17 ## [1] 119 &gt; &gt; sqrt(9) ## [1] 3 &gt; &gt; 3^3 ## [1] 27 &gt; &gt; log(7) ## [1] 1.946 &gt; &gt; log10(7) ## [1] 0.8451 2.2 Precision &gt; sin(pi/2) ## [1] 1 &gt; &gt; pi ## [1] 3.142 &gt; &gt; options(digits = 22) &gt; &gt; pi ## [1] 3.141592653589793115998 &gt; &gt; options(digits = 4) 2.3 Infinity or not defined, and missings &gt; 1/0 ## [1] Inf &gt; &gt; 2 * Inf ## [1] Inf &gt; &gt; -1/0 ## [1] -Inf &gt; &gt; 0/0 ## [1] NaN &gt; &gt; c(1, 2, 3, NA, 5) ## [1] 1 2 3 NA 5 &gt; &gt; mean(c(1, 2, 3, NA, 5)) ## [1] NA &gt; &gt; mean(c(1, 2, 3, 5)) ## [1] 2.75 2.4 Important commands &gt; ls() #...display list of variables in memory &gt; &gt; ls.str() #...display the structure os the list of variables in memory &gt; &gt; rm(a) #...remove an object &gt; &gt; rm(list = ls()) #...remove ALL objects &gt; 2.5 Internal help function &gt; help(mean) # shorthand for help(mean) &gt; example(mean) # examples &gt; help.search(&quot;mean&quot;) # full information &gt; help.start() # manuals "],["data-structures.html", "3 Data structures 3.1 Vector 3.2 Matrix 3.3 Simple Functions 3.4 Default arguments 3.5 Integrals and derivatives 3.6 Simple plots", " 3 Data structures In R we have objects which are functions and objects which are data. Function examples: sin() integrate() plot() paste() Data examples: 42 1:5 “R” matrix(1:12, nrow=4, ncol=3) data.frame(a=1:5, tmt=c(“a”,“b”,“a”,“b”,“a”)) list(x=2, y=“abc”, x=1:10) 3.1 Vector &gt; # Vector of numbers, e.g: &gt; c(1, 1.2, pi, exp(1)) ## [1] 1.000 1.200 3.142 2.718 &gt; &gt; # We can have vectors of other things too, e.g: &gt; c(TRUE, 1 == 2) ## [1] TRUE FALSE &gt; c(&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;) ## [1] &quot;a&quot; &quot;ab&quot; &quot;abc&quot; &gt; &gt; # But not combinations, e.g: &gt; c(&quot;a&quot;, 5, 1 == 2) ## [1] &quot;a&quot; &quot;5&quot; &quot;FALSE&quot; &gt; # Notice that R just turned everything into characters! 3.1.1 Constructing vectors &gt; # Integers from 9 to 17 &gt; x &lt;- 9:17 &gt; x ## [1] 9 10 11 12 13 14 15 16 17 &gt; &gt; # A sequence of 11 numbers from 0 to 1 &gt; y &lt;- seq(0, 1, length = 11) &gt; y ## [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 &gt; &gt; # The same number or the same vector several times &gt; z &lt;- rep(1:2, 5) &gt; z ## [1] 1 2 1 2 1 2 1 2 1 2 &gt; &gt; # Combine numbers, vectors or both into a new vector &gt; xz10 &lt;- c(x, z, 10) &gt; xz10 ## [1] 9 10 11 12 13 14 15 16 17 1 2 1 2 1 2 1 2 1 2 10 3.1.2 Index and logical index &gt; # Define a vector with integers from (-5) to 5 and extract the numbers with &gt; # absolute value less than 3: &gt; x &lt;- (-5):5 &gt; x ## [1] -5 -4 -3 -2 -1 0 1 2 3 4 5 &gt; &gt; # by their index in the vector: &gt; x[4:8] ## [1] -2 -1 0 1 2 &gt; &gt; # or, by negative selection (set a minus in front of the indices we don&#39;t &gt; # want): &gt; x[-c(1:3, 9:11)] ## [1] -2 -1 0 1 2 &gt; &gt; # A logical vector can be defined by: &gt; index &lt;- abs(x) &lt; 3 &gt; index ## [1] FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE &gt; &gt; # Now this vector can be used to extract the wanted numbers: &gt; x[index] ## [1] -2 -1 0 1 2 3.2 Matrix Similar to vectors we can have matrices of objects of the same type, e.g: &gt; matrix(c(1, 2, 3, 4, 5, 6) + pi, nrow = 2) ## [,1] [,2] [,3] ## [1,] 4.142 6.142 8.142 ## [2,] 5.142 7.142 9.142 &gt; &gt; matrix(c(1, 2, 3, 4, 5, 6) + pi, nrow = 2) &lt; 6 ## [,1] [,2] [,3] ## [1,] TRUE FALSE FALSE ## [2,] TRUE FALSE FALSE &gt; &gt; # We can create higher order arrays, e.g: &gt; array(c(1:24), dim = c(4, 3, 2)) ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 13 17 21 ## [2,] 14 18 22 ## [3,] 15 19 23 ## [4,] 16 20 24 3.2.1 Constructing matrices &gt; &gt; # Combine rows into a matrix &gt; A &lt;- rbind(1:3, c(1, 1, 2)) &gt; A ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 1 1 2 &gt; &gt; # Or columns &gt; B &lt;- cbind(1:3, c(1, 1, 2)) &gt; B ## [,1] [,2] ## [1,] 1 1 ## [2,] 2 1 ## [3,] 3 2 &gt; &gt; # Define a matrix from one long vector &gt; C &lt;- matrix(c(1, 0, 0, 1, 1, 0, 1, 1, 1), nrow = 3, ncol = 3) &gt; C ## [,1] [,2] [,3] ## [1,] 1 1 1 ## [2,] 0 1 1 ## [3,] 0 0 1 &gt; &gt; # Can also be done by rows by adding &#39;byrow=TRUE&#39; before the last parenthesis. &gt; # Try! 3.2.2 Index and logical index &gt; A &lt;- matrix((-4):5, nrow = 2, ncol = 5) &gt; A ## [,1] [,2] [,3] [,4] [,5] ## [1,] -4 -2 0 2 4 ## [2,] -3 -1 1 3 5 &gt; &gt; &gt; # Negative values &gt; A[A &lt; 0] ## [1] -4 -3 -2 -1 &gt; &gt; # Assignments &gt; A[A &lt; 0] &lt;- 0 &gt; A ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0 0 0 2 4 ## [2,] 0 0 1 3 5 &gt; &gt; # Matrix rows can be selected by &gt; A[2, ] ## [1] 0 0 1 3 5 &gt; &gt; # and similarly for columns &gt; A[, c(2, 4)] ## [,1] [,2] ## [1,] 0 2 ## [2,] 0 3 3.2.3 Properties of vectors and matrices The R function mode() when applied to a vector or to a matrix detects the type of singles that is stored: &gt; A &lt;- matrix(rep(c(TRUE, FALSE), 2), nrow = 2) &gt; &gt; B &lt;- rnorm(4) &gt; &gt; C &lt;- matrix(LETTERS[1:9], nrow = 3) &gt; &gt; A ## [,1] [,2] ## [1,] TRUE TRUE ## [2,] FALSE FALSE &gt; B ## [1] 0.2828 1.2518 -0.1151 0.8643 &gt; C ## [,1] [,2] [,3] ## [1,] &quot;A&quot; &quot;D&quot; &quot;G&quot; ## [2,] &quot;B&quot; &quot;E&quot; &quot;H&quot; ## [3,] &quot;C&quot; &quot;F&quot; &quot;I&quot; &gt; &gt; mode(A) ## [1] &quot;logical&quot; &gt; mode(B) ## [1] &quot;numeric&quot; &gt; mode(C) ## [1] &quot;character&quot; Vectors and matrices have lengths: the length is the number of elements: &gt; x &lt;- matrix(c(NA, 2:12), ncol = 3) &gt; x ## [,1] [,2] [,3] ## [1,] NA 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 &gt; &gt; length(x[1, ]) ## [1] 3 &gt; &gt; length(x) ## [1] 12 &gt; &gt; # The dimension of a matrix is the number of rows and columns: The number of &gt; # columns is the second element: &gt; dim(x) ## [1] 4 3 &gt; dim(x)[2] ## [1] 3 3.2.4 Naming rows and columns in a matrix We can add names to a matrix with the colnames() and rownames() functions: &gt; x &lt;- matrix(rnorm(12), nrow = 4) &gt; x ## [,1] [,2] [,3] ## [1,] -1.4674 -2.11745 -0.4322 ## [2,] -1.7250 -0.02905 0.3034 ## [3,] 2.5618 2.40387 -0.2860 ## [4,] -0.5431 0.55772 -0.4009 &gt; &gt; colnames(x) &lt;- paste(&quot;data&quot;, 1:3, sep = &quot;&quot;) &gt; &gt; rownames(x) &lt;- paste(&quot;obs&quot;, 1:4, sep = &quot;&quot;) &gt; &gt; x ## data1 data2 data3 ## obs1 -1.4674 -2.11745 -0.4322 ## obs2 -1.7250 -0.02905 0.3034 ## obs3 2.5618 2.40387 -0.2860 ## obs4 -0.5431 0.55772 -0.4009 &gt; &gt; y &lt;- matrix(rnorm(15), nrow = 5) &gt; y ## [,1] [,2] [,3] ## [1,] -0.4613 0.93541 1.5811 ## [2,] 0.3347 0.05065 -1.3580 ## [3,] 1.3099 1.77019 0.4667 ## [4,] -0.2948 -0.49271 -0.4951 ## [5,] -0.8083 -1.25855 0.4335 &gt; &gt; colnames(y) &lt;- LETTERS[1:ncol(y)] &gt; &gt; rownames(y) &lt;- letters[1:nrow(y)] &gt; &gt; y ## A B C ## a -0.4613 0.93541 1.5811 ## b 0.3347 0.05065 -1.3580 ## c 1.3099 1.77019 0.4667 ## d -0.2948 -0.49271 -0.4951 ## e -0.8083 -1.25855 0.4335 3.2.5 Matrix multiplication &gt; M &lt;- matrix(rnorm(20), nrow = 4, ncol = 5) &gt; N &lt;- matrix(rnorm(15), nrow = 5, ncol = 3) &gt; &gt; M %*% N ## [,1] [,2] [,3] ## [1,] -0.74193 2.3186 -0.26987 ## [2,] -0.70372 -0.3569 0.51286 ## [3,] -0.78080 1.0136 -0.08753 ## [4,] 0.04846 -0.4733 0.30275 &gt; &gt; # Can we perform N*M? No! A and B are not compatible!! Try to run: N%*%M 3.2.6 Additional functions &gt; M &lt;- matrix(rnorm(16), nrow = 4, ncol = 4) &gt; &gt; dim(M) ## [1] 4 4 &gt; &gt; t(M) ## [,1] [,2] [,3] [,4] ## [1,] 0.2179 0.50001 -0.4868 1.4590 ## [2,] -0.3014 -0.03050 1.7561 0.8646 ## [3,] -0.6529 0.05847 0.5901 -0.4382 ## [4,] 1.0106 0.76520 -0.8804 0.2014 &gt; &gt; det(M) ## [1] 1.509 &gt; &gt; (invM &lt;- solve(M)) ## [,1] [,2] [,3] [,4] ## [1,] -0.6866 0.32134 -0.38309 0.5500 ## [2,] 0.4628 0.04103 0.59313 0.1147 ## [3,] -1.1190 1.59946 0.01999 -0.3743 ## [4,] 0.5526 0.97628 0.27243 -0.3262 &gt; &gt; eigen(M) ## eigen() decomposition ## $values ## [1] 1.6490 -1.2244 1.1851 -0.6308 ## ## $vectors ## [,1] [,2] [,3] [,4] ## [1,] 0.45181 -0.2806 -0.2549 0.50829 ## [2,] 0.47611 -0.3449 -0.5510 -0.41440 ## [3,] -0.04433 0.5869 -0.4160 0.75216 ## [4,] 0.75314 0.6767 -0.6770 -0.06452 3.3 Simple Functions The above functions are built-in functions. However, it is simple to write your own functions: &gt; # a square function &gt; square &lt;- function(x) { + x * x + } &gt; &gt; square(2) ## [1] 4 &gt; square(1:5) ## [1] 1 4 9 16 25 &gt; &gt; # a power function with two arguments &gt; power &lt;- function(x, pow) { + x^pow + } &gt; &gt; power(2, 3) ## [1] 8 &gt; power(1:5, 3) ## [1] 1 8 27 64 125 3.4 Default arguments A function can have default arguments: &gt; power &lt;- function(x, pow = 2) { + x^pow + } &gt; &gt; power(1:5) ## [1] 1 4 9 16 25 &gt; &gt; power(1:5, 4) ## [1] 1 16 81 256 625 3.5 Integrals and derivatives &gt; f &lt;- function(x) (x^2) * exp(x) &gt; integrate(f, 0, 1) ## 0.7183 with absolute error &lt; 8e-15 &gt; &gt; # check: str(integrate(f,0,1)). &gt; f &lt;- expression((x^2) * exp(x)) &gt; (df &lt;- D(f, &quot;x&quot;)) ## 2 * x * exp(x) + (x^2) * exp(x) &gt; &gt; x &lt;- c(0, 3, 10) &gt; eval(df) ## [1] 0.0 301.3 2643175.9 3.6 Simple plots &gt; x &lt;- seq(0, 6, length = 100) &gt; &gt; y &lt;- 2 * x + 3 + rnorm(100) &gt; &gt; plot(x, y) &gt; &gt; plot(sin, 0, 2 * pi) 3.6.1 Histogram and boxplot &gt; hist(rnorm(1000), main = &quot;My histogram&quot;, xlab = &quot;X&quot;, ylab = &quot;Y&quot;) &gt; boxplot(rnorm(1000), main = &quot;My boxplot&quot;) "],["loops-and-flow-control.html", "4 Loops and flow control 4.1 Loops with for 4.2 Flow control: if and if else statements 4.3 While loop example", " 4 Loops and flow control 4.1 Loops with for In R the for loop is used perform a task for each element in a set. The syntax is: &gt; for (var in num1:num2) { + instruction1 + instruction2 + ... + } Example: &gt; y &lt;- sample(1:5) &gt; z &lt;- c() &gt; for (i in 1:5) { + z[i] &lt;- y[i]^2 + } &gt; z ## [1] 1 25 9 4 16 Another example: &gt; M &lt;- matrix(sample(1:12), 4, 3) &gt; M ## [,1] [,2] [,3] ## [1,] 6 12 1 ## [2,] 3 10 8 ## [3,] 11 9 5 ## [4,] 2 4 7 &gt; &gt; for (i in 1:4) { + for (j in 1:3) { + print(paste(&quot;M(&quot;, i, &quot;,&quot;, j, &quot;) =&quot;, M[i, j])) + } + } ## [1] &quot;M( 1 , 1 ) = 6&quot; ## [1] &quot;M( 1 , 2 ) = 12&quot; ## [1] &quot;M( 1 , 3 ) = 1&quot; ## [1] &quot;M( 2 , 1 ) = 3&quot; ## [1] &quot;M( 2 , 2 ) = 10&quot; ## [1] &quot;M( 2 , 3 ) = 8&quot; ## [1] &quot;M( 3 , 1 ) = 11&quot; ## [1] &quot;M( 3 , 2 ) = 9&quot; ## [1] &quot;M( 3 , 3 ) = 5&quot; ## [1] &quot;M( 4 , 1 ) = 2&quot; ## [1] &quot;M( 4 , 2 ) = 4&quot; ## [1] &quot;M( 4 , 3 ) = 7&quot; 4.2 Flow control: if and if else statements The syntax is: if (condition){ expression_if_true else expression_if_false } Example: &gt; (x &lt;- sample(1:3)) ## [1] 1 3 2 &gt; &gt; if (x[1] &lt; x[2] &amp; x[2] &lt; x[3]) print(&quot;Ordered vector&quot;) else print(sort(x)) ## [1] 1 2 3 &gt; (x &lt;- 1:3) ## [1] 1 2 3 &gt; &gt; if (x[1] &lt; x[2] &amp; x[2] &lt; x[3]) print(&quot;Ordered vector&quot;) else print(sort(x)) ## [1] &quot;Ordered vector&quot; Another example: &gt; for (i in 1:3) { + if (i == 2) + print(&quot;The index is 2&quot;) else print(&quot;The index is not 2&quot;) + } ## [1] &quot;The index is not 2&quot; ## [1] &quot;The index is 2&quot; ## [1] &quot;The index is not 2&quot; A shorter version… &gt; ifelse(condition, expression_if_true, expression_if_false) &gt; (x &lt;- rnorm(2, 0, 1)) ## [1] 0.401 1.076 &gt; ifelse(x[1] &lt; x[2], &quot;True&quot;, &quot;False&quot;) ## [1] &quot;True&quot; 4.3 While loop example The while loop: while(cond) expr &gt; x &lt;- 1 &gt; while (x &lt; 5) { + x &lt;- x + 1 + print(x) + } ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 &gt; x &lt;- 1 &gt; while (x &lt; 5) { + print(x) + x &lt;- x + 1 + } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 "],["simulation.html", "5 Simulation 5.1 The set.seed()function 5.2 Random numbers and probability distributions 5.3 Monte Carlo integration (example)", " 5 Simulation Random numbers can be used for: simulation of complex systems encryption bootstrap methods (the bootstrap method is a resampling technique used to estimate statistics on a population by sampling a dataset with replacement. It can be used to estimate summary statistics such as the mean or standard deviation \\(\\Longrightarrow\\) Risk models course) design of experiments performance testing simulation testing of models and estimation … How do we get random numbers? Use a natural phenomena. E.g: a dice, a deck of cards, … Use a table of random numbers. Computer algorithm: easy, but the algorithm should be: carefully selected fast simple reproducible Item 3 is included in R. It is easy to simulate from most distributions of interest! Random numbers (in R) are actually called pseudo-random numbers (because the algorithm can repeat the sequence, and the numbers are thus not entirely random). Generated from an algorithm. For all practical purposes, pseudo-random numbers behave like true random numbers. By specifying the input to the algorithm, pseudo-random numbers can be re-created. The default pseudo random number generator in R is the Mersenne Twister. In R the Mersenne Twister uses a random seed as input: constructed from time and session ID. You can replace the random seed with a fixed seed with the set.seed() function. 5.1 The set.seed()function Sets of random numbers: &gt; set.seed(12345) &gt; rnorm(3) ## [1] 0.5855 0.7095 -0.1093 &gt; rnorm(5) ## [1] -0.4535 0.6059 -1.8180 0.6301 -0.2762 &gt; rnorm(3) ## [1] -0.2842 -0.9193 -0.1162 5.2 Random numbers and probability distributions Very useful link. Simulation from a uniform distribution: &gt; runif(5, min = 1, max = 2) ## [1] 1.965 1.707 1.645 1.390 1.699 Simulation from a normal distribution: &gt; rnorm(5, mean = 2, sd = 1) ## [1] 2.1107 1.9613 -0.5129 2.4728 1.6459 Simulation from a gamma distribution: &gt; rgamma(5, shape = 2, rate = 1) ## [1] 3.5252 0.4502 3.8128 0.8147 0.1360 Simulation from a binomial distribution: &gt; rbinom(5, size = 100, prob = 0.3) ## [1] 34 35 35 26 19 List of functions: &gt; # Density -&gt; d &gt; dnorm(x, mean = 0, sd = 1, log = FALSE) &gt; &gt; # Distribution function -&gt; p &gt; pnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) &gt; &gt; # Quantile function -&gt; q &gt; qnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) &gt; &gt; # Random generator -&gt; r &gt; rnorm(n, mean = 0, sd = 1) Remember… Figure 5.1: Standard Gaussian distribution. Distributions: &gt; &gt; # normal: dnorm(x=..., mean=..., sd=...); x is a quantile. &gt; &gt; # dnorm(0,0,1) = 1/sqrt(2*pi) &gt; dnorm(0, 0, 1) ## [1] 0.3989 &gt; dnorm(0, 0, 1) == 1/sqrt(2 * pi) ## [1] TRUE &gt; &gt; # normal: pnorm(q=..., mean=..., sd=...); q is a quantile. &gt; pnorm(0, 0, 1) ## [1] 0.5 &gt; pnorm(-1.96, 0, 1) ## [1] 0.025 &gt; pnorm(-1.64, 0, 1) ## [1] 0.0505 &gt; pnorm(1.96, 0, 1) ## [1] 0.975 &gt; pnorm(1.64, 0, 1) ## [1] 0.9495 &gt; &gt; # normal: qnorm(p=..., mean=..., sd=...); p is a probability. &gt; qnorm(0.5, 0, 1) ## [1] 0 &gt; qnorm(0.95, 0, 1) ## [1] 1.645 &gt; qnorm(0.975, 0, 1) ## [1] 1.96 5.3 Monte Carlo integration (example) Consider the function \\(f(x)=e^{2\\cos(x-\\pi)}\\) and compute the integral \\[\\int\\limits_0^{2\\pi} f(x) dx:\\] &gt; rm(list = ls()) &gt; f &lt;- function(x) exp(2 * cos(x - pi)) &gt; plot(f, 0, 2 * pi, lwd = 3) Monte Carlo method: simulate uniformly distributed points \\((x_1,~y_1), \\ldots, (x_n,~y_n)\\) in \\([0, ~2\\pi] \\times [0,~8]\\) within a “box”. Note that \\(0&lt;f(x)&lt;e^{2}, ~\\forall ~x \\in [0, ~2\\pi]\\): &gt; set.seed(1234) &gt; plot(f, 0, 2 * pi, lwd = 3) &gt; x &lt;- runif(1000, 0, 2 * pi) &gt; y &lt;- runif(1000, 0, exp(2)) &gt; mycol &lt;- ifelse(y &lt; f(x), &quot;blue&quot;, &quot;green&quot;) &gt; points(x, y, col = mycol) (to get a wider view of what’s happening:) &gt; set.seed(1234) &gt; plot(f, 0, 2 * pi, xlim = c(-1, 10), ylim = c(-1, 10), lwd = 3) &gt; x &lt;- runif(1000, 0, 2 * pi) &gt; y &lt;- runif(1000, 0, exp(2)) &gt; mycol &lt;- ifelse(y &lt; f(x), &quot;blue&quot;, &quot;green&quot;) &gt; points(x, y, col = mycol) estimate the probability of points (say \\(m\\)) being below the curve of \\(f\\): \\(m/n\\). the area of the “box” is \\(2\\pi \\times e^2 \\approx 46.43\\), so the estimated integral, i.e., the area under the curve, becomes \\[\\int\\limits_0^{2\\pi} f(x) dx \\approx 46.43 \\times \\frac{m}{n}.\\] &gt; set.seed(4321) &gt; &gt; x &lt;- runif(1e+06, 0, 2 * pi) &gt; y &lt;- runif(1e+06, 0, exp(2)) &gt; m.over.n &lt;- sum(y &lt; f(x))/length(x) &gt; &gt; options(digits = 20) &gt; (MCint &lt;- m.over.n * 46.43) ## [1] 14.325558629999999738 &gt; &gt; # &#39;real&#39; value &gt; (Realint &lt;- integrate(f, 0, 2 * pi)$value) ## [1] 14.323056878100514311 &gt; &gt; (MCint - Realint) ## [1] 0.0025017518994854270886 &gt; &gt; options(digits = 4) "],["graphics-in-r-exploratory-learning.html", "6 Graphics in R (exploratory learning) 6.1 base", " 6 Graphics in R (exploratory learning) 6.1 base The original (default) graphics system in R. Highly customizable. Complex plots require many code lines. &gt; demo(graphics) &gt; demo(persp) All the code. Try it! &gt; library(datasets) &gt; library(grDevices) &gt; library(graphics) &gt; library(gridGraphics) &gt; &gt; &gt; # demo1 &gt; x &lt;- stats::rnorm(50) &gt; par(bg = &quot;white&quot;) &gt; plot(x, ann = FALSE, type = &quot;n&quot;) &gt; abline(h = 0, col = gray(0.9)) &gt; lines(x, col = &quot;green4&quot;, lty = &quot;dotted&quot;) &gt; points(x, bg = &quot;limegreen&quot;, pch = 21) &gt; title(main = &quot;Simple Use of Color In a Plot&quot;, xlab = &quot;Just a Whisper of a Label&quot;, + col.main = &quot;blue&quot;, col.lab = gray(0.8), cex.main = 1.2, cex.lab = 1, font.main = 4, + font.lab = 3) &gt; &gt; # demo2 &gt; par(bg = &quot;gray&quot;) &gt; pie(rep(1, 24), col = rainbow(24), radius = 0.9) &gt; title(main = &quot;A Sample Color Wheel&quot;, cex.main = 1.4, font.main = 3) &gt; title(xlab = &quot;(Use this as a test of monitor linearity)&quot;, cex.lab = 0.8, font.lab = 3) &gt; &gt; # demo3 &gt; pie.sales &lt;- c(0.12, 0.3, 0.26, 0.16, 0.04, 0.12) &gt; names(pie.sales) &lt;- c(&quot;Blueberry&quot;, &quot;Cherry&quot;, &quot;Apple&quot;, &quot;Boston Cream&quot;, &quot;Other&quot;, &quot;Vanilla Cream&quot;) &gt; pie(pie.sales, col = c(&quot;purple&quot;, &quot;violetred1&quot;, &quot;green3&quot;, &quot;cornsilk&quot;, &quot;cyan&quot;, &quot;white&quot;)) &gt; title(main = &quot;January Pie Sales&quot;, cex.main = 1.8, font.main = 1) &gt; title(xlab = &quot;(Don&#39;t try this at home kids)&quot;, cex.lab = 0.8, font.lab = 3) &gt; &gt; # demo4 &gt; par(bg = &quot;cornsilk&quot;) &gt; n &lt;- 10 &gt; g &lt;- gl(n, 100, n * 100) &gt; x &lt;- rnorm(n * 100) + sqrt(as.numeric(g)) &gt; boxplot(split(x, g), col = &quot;lavender&quot;, notch = TRUE) &gt; title(main = &quot;Notched Boxplots&quot;, xlab = &quot;Group&quot;, font.main = 4, font.lab = 1) &gt; &gt; # demo5 &gt; par(bg = &quot;white&quot;) &gt; n &lt;- 100 &gt; x &lt;- c(0, cumsum(rnorm(n))) &gt; y &lt;- c(0, cumsum(rnorm(n))) &gt; xx &lt;- c(0:n, n:0) &gt; yy &lt;- c(x, rev(y)) &gt; plot(xx, yy, type = &quot;n&quot;, xlab = &quot;Time&quot;, ylab = &quot;Distance&quot;) &gt; polygon(xx, yy, col = &quot;gray&quot;) &gt; title(&quot;Distance Between Brownian Motions&quot;) &gt; &gt; &gt; # demo6 &gt; x &lt;- c(0, 0.4, 0.86, 0.85, 0.69, 0.48, 0.54, 1.09, 1.11, 1.73, 2.05, 2.02) &gt; par(bg = &quot;lightgray&quot;) &gt; plot(x, type = &quot;n&quot;, axes = FALSE, ann = FALSE) &gt; usr &lt;- par(&quot;usr&quot;) &gt; rect(usr[1], usr[3], usr[2], usr[4], col = &quot;cornsilk&quot;, border = &quot;black&quot;) &gt; lines(x, col = &quot;blue&quot;) &gt; points(x, pch = 21, bg = &quot;lightcyan&quot;, cex = 1.25) &gt; axis(2, col.axis = &quot;blue&quot;, las = 1) &gt; axis(1, at = 1:12, lab = month.abb, col.axis = &quot;blue&quot;) &gt; box() &gt; title(main = &quot;The Level of Interest in R&quot;, font.main = 4, col.main = &quot;red&quot;) &gt; title(xlab = &quot;1996&quot;, col.lab = &quot;red&quot;) &gt; &gt; # demo7 &gt; par(bg = &quot;cornsilk&quot;) &gt; set.seed(1) &gt; x &lt;- rnorm(1000) &gt; hist(x, xlim = range(-4, 4, x), col = &quot;lavender&quot;, main = &quot;&quot;) &gt; title(main = &quot;1000 Normal Random Variates&quot;, font.main = 3) &gt; &gt; # demo8 &gt; pairs(iris[1:4], main = &quot;Edgar Anderson&#39;s Iris Data&quot;, font.main = 4, pch = 19) &gt; &gt; # demo9 &gt; pairs(iris[1:4], main = &quot;Edgar Anderson&#39;s Iris Data&quot;, pch = 21, bg = c(&quot;red&quot;, &quot;green3&quot;, + &quot;blue&quot;)[unclass(iris$Species)]) &gt; &gt; # demo10 &gt; x &lt;- 10 * 1:nrow(volcano) &gt; y &lt;- 10 * 1:ncol(volcano) &gt; lev &lt;- pretty(range(volcano), 10) &gt; par(bg = &quot;lightcyan&quot;) &gt; pin &lt;- par(&quot;pin&quot;) &gt; xdelta &lt;- diff(range(x)) &gt; ydelta &lt;- diff(range(y)) &gt; xscale &lt;- pin[1]/xdelta &gt; yscale &lt;- pin[2]/ydelta &gt; scale &lt;- min(xscale, yscale) &gt; xadd &lt;- 0.5 * (pin[1]/scale - xdelta) &gt; yadd &lt;- 0.5 * (pin[2]/scale - ydelta) &gt; plot(numeric(0), numeric(0), xlim = range(x) + c(-1, 1) * xadd, ylim = range(y) + + c(-1, 1) * yadd, type = &quot;n&quot;, ann = FALSE) &gt; usr &lt;- par(&quot;usr&quot;) &gt; rect(usr[1], usr[3], usr[2], usr[4], col = &quot;green3&quot;) &gt; clines &lt;- contourLines(x, y, volcano, levels = lev) &gt; lapply(clines, lines, col = &quot;yellow&quot;, lty = &quot;solid&quot;) &gt; box() &gt; title(&quot;A Topographic Map of Maunga Whau&quot;, font = 4) &gt; title(xlab = &quot;Meters North&quot;, ylab = &quot;Meters West&quot;, font = 3) &gt; mtext(&quot;10 Meter Contour Spacing&quot;, side = 3, line = 0.35, outer = FALSE, at = mean(par(&quot;usr&quot;)[1:2]), + cex = 0.7, font = 3) &gt; &gt; # demo11 &gt; par(bg = &quot;cornsilk&quot;) &gt; coplot(lat ~ long | depth, data = quakes, pch = 21, bg = &quot;green3&quot;) "],["mathematical-methods-in-finance.html", "7 Mathematical Methods in Finance 7.1 Introduction 7.2 The binomial model 7.3 The Black-Scholes model", " 7 Mathematical Methods in Finance 7.1 Introduction A derivative is a contract which promises to make a payment at a specified time in the future, the amount of which depends upon the behavior of some underlying asset (or market variable) up to and including the time of the payment. Examples: Options on stocks: the underlying asset is the price of stock shares. Futures contract on wheat: the underlying asset is the price of wheat. Forward contract for selling US dollars: the underlying asset is the exchange rate EUR-USD. Derivatives may depend on many other variables: interest rates, indexes, electricity price, etc. Other derivatives are credit derivatives, insurance derivatives, weather derivatives, etc… Definition 7.1 We will work with European options. Remember some definitions on Options: Call option (“call”): A call option gives the holder the right (but not the obligation) to buy the underlying asset by a certain date \\(T\\) for a certain price \\(K\\). Put option (“put”): A put option gives the holder the right (but not the obligation) to sell the underlying asset by a certain date \\(T\\) for a certain price \\(K\\). The price \\(K\\) in the contract is known as the exercise price or strike price. The date \\(T\\) in the contract is known as the expiration date or maturity. European options can be exercised only on the expiration date itself. American options can be exercised at any time up to the expiration date. Long position: investor that buys the option. Short position: investor that sells the option (writer of the option). Long position on a “call”: \\(\\mbox{Payoff}=\\max\\{S_T-K,0\\}\\). Short position on a “call”: \\(\\mbox{Payoff}=-\\max\\{S_T-K,0\\}=\\min\\{K-S_T,0\\}\\). Long position on a “put”: \\(\\mbox{Payoff}=\\max\\{K-S_T,0\\}\\). Short position on a “put”: \\(\\mbox{Payoff}=-\\max\\{K-S_T,0\\}=\\min\\{S_T-K,0\\}\\). Remark. Notation: \\(t\\) is the current time. \\(S_t\\) is the underlying share price at time \\(t\\). \\(K\\) is the strike or exercise price. \\(T\\) is the option expiry date. \\(C_t\\) is the price at time \\(t\\) of European call options. \\(P_t\\) is the price at time \\(t\\) of European put options. \\(c_t\\) is the price at time \\(t\\) of American call options. \\(p_t\\) is the price at time \\(t\\) of American put options. \\(r\\) is the risk-free rate of interest (assumed constant). Remark. Terminology: A call option is: in-the-money if \\(S_t&gt;K\\). out-of-money if \\(S_t&lt;K\\). at-the-money if \\(S_t=K\\). A put option is: in-the-money if \\(S_t&lt;K\\). out-of-money if \\(S_t&gt;K\\). at-the-money if \\(S_t=K\\). 7.2 The binomial model This section introduces the binomial tree model and uses it to compute arbitrage-free prices for European-style options. Although the mathematical description of this model involves only simple algebra, it is a powerful tool to understand arbitrage pricing theory. The main idea of the binomial model is to break the time to maturity of an option into periods. Then, in each period, and given the underlying asset’s price at the beginning of the period, it assumes that the stock price will change to one of two possible values at the end of the period. Thus, we can then determine the value of the option recursively by starting at the maturity date, evaluating the option’s value under each possibility for the final prices of the stock, and then moving backward through the (binomial) tree. The binomial model is a model in discrete time and it leads to the celebrated Black-Scholes model (a continuous time model) as a limiting case. Basic assumptions of the binomial model: (1) no trading costs or taxes; (2) no minimum or maximum units of trading; (3) stocks and bounds can only be traded at discrete times (\\(t=1, 2, 3, \\ldots\\)); (4) the principle of no arbitrage holds. 7.2.1 One-period binomial model We start with the one-period version of the model. The model assumes that we have two assets: a risk-free asset (e.g., a treasury bond, currency, …) and a stock. Here, we denote by \\(B_t\\) and \\(S_t\\) the bond and stock prices at time \\(t\\), respectively. Typically, time \\(t = 0\\) represents the present time, and \\(t = 1\\) denotes some future time. Let us begin by describing the behavior of the stock prices. If at time \\(t= 0\\) the price is \\(S_0\\), then the stock price at time \\(t = 1\\), \\(S_1\\), is given by the following random variable \\[ S_1 = \\left\\{ \\begin{matrix} u S_0\\,, &amp; \\text{with probability } p_u \\text{ (i.e., if the price goes up) } \\\\ d S_0\\,, &amp; \\text{with probability } p_d \\text{ (i.e., if the price goes down) } , \\end{matrix}\\right. \\] where \\(u&gt;1\\), \\(d&lt;1\\), \\(p_u\\), and \\(p_d\\) are positive positive constants satisfying \\(d&lt;u\\), and \\(p_u+p_d =1\\). Figure 7.1 shows the development of the price of a stock under the above specification. Figure 7.1: Stock prices in a one-period binomial tree. It is often convenient to write instead \\[S_1 = S_0 Z,\\] where \\(Z\\) is a random variable defined as \\[ Z = \\left\\{ \\begin{matrix} u \\,, &amp; \\text{with probability } p_u \\,,\\\\ d \\,, &amp; \\text{with probability } p_d \\,. \\end{matrix}\\right. \\] On the other hand, the bond price is deterministic and given by \\[\\begin{align*} &amp; B_0 = 1 \\,, \\\\ &amp; B_1 = 1 + R \\,, \\end{align*}\\] where R is the interest rate for the period. Remark. We may consider a bond with a continuous interest rate, i.e., \\[B_1=e^{R}, \\quad R&gt;0.\\] Remember: \\(e^x\\approx 1+x\\). Portfolios and arbitrage We will consider portfolios constituted of risky assets \\(S\\) and bonds \\(B\\). More specifically, we will denote by \\(x\\) the number of bonds we hold in our portfolio, \\(y\\) the number of stock units held, and let \\(h = (x,y)\\). Consider now a fixed portfolio \\(h = (x, y)\\). Then, the value of the portfolio at time \\(t\\), \\(V_{t}^h\\), is given by \\[ V_{t}^h = x B_t + y S_t \\,. \\] Note that this portfolio has a deterministic value at \\(t = 0\\), \\(V_{0}^h = x B_0 + y S_0\\), and a stochastic value at \\(t = 1\\), \\(V_{1}^h = x B_1 + y S_1=x B_1 + y S_0Z\\), where \\(Z\\) is a r.v. We now introduce one of the central concepts of the theory in this section: arbitrage. An arbitrage opportunity is a strategy where we can make a sure profit with no risk (“a free lunch”). Generally speaking, an arbitrage strategy can be created by: Start at time zero with a portfolio that has a net value of zero (implying that we are long in some assets and short in others); At some future time \\(T\\): \\[P(&quot;loss&quot;)=0 \\quad \\text{and} \\quad P(&quot;positive ~ profit&quot;)&gt;0.\\]. If an arbitrage opportunity exists, all the market participants would exploit it, and the market prices of the assets in the portfolio would quickly change to remove the arbitrage opportunity. Formally, Definition 7.2 An arbitrage portfolio is a portfolio \\(h\\) with the properties \\[\\begin{align*} &amp;V_{0}^h = 0 \\,,\\\\ &amp; V_{1}^h &gt;0 \\quad \\text{with probability } 1 \\,. \\end{align*}\\] Here we will consider the Principle of No Arbitrage: arbitrage strategies do not exist. If there are no arbitrage than any two portfolios that give exactly the same payments must have the same price (“Law of One Price”). Essentially an arbitrage portfolio is a deterministic money-making machine. Hence, we can interpret the existence of an arbitrage portfolio as a severe case of mispricing on the market. Therefore, it is natural to investigate when a given market model is arbitrage-free. Example 7.1 Suppose a stock is listed on both the NYSE and NASDAQ stock exchanges and consider the following steps: A trader observes that the current price of the stock on the NYSE is $10.10 and that on the NASDAQ it is $10.20. They purchase 10,000 of the lower-priced shares (on the NYSE), costing $101,000 and simultaneously sell the same quantity of 10,000 higher-priced shares, costing $102,000. They manage to pocket the difference (102,000-101,000 = $1000) as profit (assuming there is no commissions). Effectively, arbitrage is risk-free profit. At the end of the two transactions (if executed successfully), the trader is not holding any stock position (so they are risk-free), yet they have made a profit! It turns out that our binomial model above is free of arbitrage if and only if the following conditions hold: \\[d \\leq 1 + R \\leq u \\,.\\] Remark: or, in continuous time, \\(d &lt; e^R&lt;u\\). Moreover, the above no arbitrage condition is equivalent to saying that \\(1 + R\\) is a convex combination of \\(u\\) and \\(d\\), i.e., \\[1 + R = u q_u + d q_d \\,,\\] where \\(q_u, q_d \\geq0\\) and \\(q_u + q_d = 1\\). In particular, the weights \\(q_u\\) and \\(q_d\\) can be interpreted as probabilities for a “new probability measure \\(Q\\)” with the property \\(Q(Z = u) = q_u\\), \\(Q(Z = d) = q_d\\). Denoting the expectation w.r.t. this measure by \\(\\mathbb{E}^Q\\), it is easy to see that \\[ S_0 = \\frac{1}{1+R} \\mathbb{E}^Q[S_1] \\,. \\] \\(Q\\) is known as the “risk-neutral measure”. Furthermore, \\(q_u\\) and \\(q_d\\) are explicit and given by \\[\\begin{align*} &amp; q_u = \\frac{(1 +R) - d}{u - d} \\,, \\\\ &amp; q_d = \\frac{u - (1 +R)}{u - d} \\,. \\end{align*}\\] These are known as the risk-neutral probabilities and will play an essential role in option pricing. The above motivates the concept of risk-neutral valuation: the price of an asset is the expectation at time 1, calculated using the risk-neutral probabilities, and then discounted using the risk-free rate of interest. Exercise 7.1 Obtain \\(q_u\\) and \\(q_d\\). Risk-neutral pricing Definition 7.3 A contingent claim (eg: a financial derivative such as an option) is any random variable \\(X\\) of the form \\(X = \\Phi(S_1)\\), where \\(\\Phi\\) is some given real valued function known as the contract function. The interpretation is that the contract holder receives the stochastic amount \\(X\\) at time \\(t = 1\\). Two important examples are the European call and put options. For an European call option with strike \\(K\\), we have that the \\(X = \\max(S_1 -K, 0)\\), while for the European put option with same strike \\(K\\), the claim is \\(X = \\max(K -S_1, 0)\\). In what follows, we will denote by \\(\\Phi(u)\\) and \\(\\Phi(d)\\), the evaluations \\(\\Phi(u S_0)\\) and \\(\\Phi(d S_0)\\), respectively. Our main problem is now determining the “fair” price for a given contingent claim \\(X\\). We denote the price of \\(X\\) at time \\(t\\) by \\(\\Pi(t; X)\\). For a one-period model one have \\(\\Pi(1; X)=X\\), i.e. the contract holder receives the stochastic amount \\(X\\) at time \\(t = 1\\). However, the hard part of the problem is determining \\(\\Pi(0;X)\\). The way to solve this problem is to find a portfolio \\(h\\) such that \\[ V_{1}^h = X \\,. \\] We call to \\(h\\) a hedging portfolio or a replicating portfolio (because it replicates the payoff at time 1 on the derivative without any risk). The price at \\(t = 0\\) of the claim \\(X\\) is given by \\[ \\Pi(0;X) = V_0^h \\,. \\] Let us now find the replicating portfolio \\(h = (x, y)\\) for a contingent claim \\(X\\) with contract function \\(\\Phi\\). The value of the portfolio at time \\(t=1\\) is \\[\\begin{align*} &amp; V_1^h = X = \\Phi(S_1) = \\Phi(uS_0) = \\Phi(u) \\quad \\text{if} \\quad Z = u \\,, \\\\ &amp; V_1^h = X = \\Phi(S_1) = \\Phi(dS_0) = \\Phi(d) \\quad \\text{if} \\quad Z = d \\,. \\end{align*}\\] Substituting the expression for the value of the portfolio, we obtain the following system of equations: \\[\\begin{align*} &amp; V_1^h = \\Phi(u) \\iff x B_1 + y u S_0 = \\Phi(u) \\iff x (1 +R) + y u S_0 = \\Phi(u)\\,, \\\\ &amp; V_1^h = \\Phi(d) \\iff x B_1 + y d S_0 = \\Phi(d) \\iff x (1 +R) + y d S_0 = \\Phi(d) \\,. \\end{align*}\\] Solving for \\(x\\) and \\(y\\) in the above system gives \\[\\begin{align*} &amp; x = \\frac{1}{1 + R} \\frac{u\\Phi(d) - d \\Phi(u)}{u- d}\\,, \\\\ &amp; y = \\frac{1}{S_0} \\frac{\\Phi(u) - \\Phi(d)}{u- d} \\,. \\end{align*}\\] Then, the price at \\(t = 0\\) of the claim \\(X\\), \\(\\Pi(0;X)\\), can be written as \\[\\begin{align*} \\Pi(0;X) &amp; = V_0^h \\\\ &amp; = xB_0 + y S_0 \\\\ &amp; = x + y S_0 \\\\ &amp; = \\frac{1}{1 + R} \\left( \\frac{(1+R) - d }{u- d}\\Phi(u) + \\frac{u - (1+R) }{u- d}\\Phi(d) \\right) \\,. \\end{align*}\\] Here, we recognize the risk-neutral probabilities \\(q_u\\) and \\(q_d\\), and we can rewrite the pricing formula above as \\[\\begin{align*} \\Pi(0;X) = \\frac{1}{1 + R} \\left( \\Phi(u) q_u + \\Phi(d) q_d \\right) \\,. \\end{align*}\\] Thus, the right-hand side can now be interpreted as an expected value under the risk-neutral probability measure \\(Q\\). More specifically, we have that \\[\\begin{align*} \\Pi(0;X) = \\frac{1}{1 + R} \\mathbb{E}^Q[X]\\,. \\end{align*}\\] Example 7.2 Consider a stock currently with price \\(S_0 = 50\\). The Stock’s price is expected to increase to 60 or decrease to 40 during the next year. The risk-free interest rate is 5% compounded annually. Compute the current price of a 1-year European call option with a strike price of 55. Solution. \\(\\,\\) S0 &lt;- 50 Sd &lt;- 40 Su &lt;- 60 R &lt;- 0.05 K &lt;- 55 u &lt;- Su/S0 d &lt;- Sd/S0 # Note that d &lt;= (1 + R) &lt;= u is satisfied d ## [1] 0.8 1 + R ## [1] 1.05 u ## [1] 1.2 # Risk-neutral probabilities qu &lt;- (1 + R - d)/(u - d) qu ## [1] 0.625 qd &lt;- (u - (1 + R))/(u - d) qd ## [1] 0.375 # or qd &lt;- 1 - qu qd ## [1] 0.375 phiu &lt;- max(Su - K, 0) phiu ## [1] 5 phid &lt;- max(Sd - K, 0) phid ## [1] 0 # Current price, pi(0;X): price &lt;- (phiu * qu + phid * qd)/(1 + R) price ## [1] 2.976 7.2.2 Multiperiod binomial model We now extend the one-period binomial model to multiperiod. To do so, we now let the time index \\(t\\) run from \\(t = 0\\) to \\(t = T\\), where \\(T\\) is fixed. As previously, we have a bond with price \\(B_t\\) and a stock with price \\(S_t\\) at time \\(t\\). More specifically, the bond prices are deterministic and given by \\[\\begin{align*} &amp; B_0 = 1 \\,, \\\\ &amp; B_{n+1} = (1 + R) B_n \\,, \\quad n = 0, \\dots, T-1 \\end{align*}\\] On the other hand, if at time \\(t= 0\\) the price of the stock is \\(S_0\\), then the future stock prices are random and given by \\[\\begin{align*} S_{n+1} = Z_n S_n \\,, \\quad n = 0, \\dots, T-1 \\end{align*}\\] where \\(Z_{0}, . . . , Z_{T-1}\\) are iid random variables, taking only the two values \\(u\\) and \\(d\\) with probabilities \\[\\begin{align*} \\mathbb{P}(Z_n =u)=p_u \\,, \\quad \\mathbb{P}(Z_n = d) = p_d \\,. \\end{align*}\\] In other words, during each time step, the stock price either moves up to \\(u\\) times its initial value or moves down to \\(d\\) times its initial value. Figure 7.2 shows the behavior of the stock price for \\(T = 2\\). Figure 7.2: Multiperiod binomial tree. Note that the prices of the stock at time \\(t\\) can be written as \\[S_t = u^{k}d^{t-k} S_0 \\,, \\quad k = 0,\\dots,t\\,,\\] where \\(k\\) denotes the number of up-moves that have occurred. Thus, each node in the binomial tree can be represented by a pair \\((t,k)\\) with \\(k = 0,\\dots,t\\). Figure 7.3 shows the representation of the nodes of a binomial tree for \\(T = 2\\). Figure 7.3: Nodes of a multiperiod binomial tree. Recall that the main aim is to find the arbitrage-free price of a given contingent claim (a financial derivative, for instance). In particular, we will only work with contingent claims of the form \\[X = \\Phi (S_T) \\,,\\] that is, claims whose value only depends on the stock price at the final time \\(T\\), \\(S_T\\). This type of contingent claims is typically called simple. Note that the European Call and Put options are examples of simple claims. As in the one-period model, the problem is solved by finding a portfolio \\(h\\) that replicates the final value of the contingent claim, that is, if \\(V_t^h\\) denotes the value of the portfolio at time \\(t\\), we require that (recall the definition of contingent claim) \\[ V_T^h = X = \\Phi(S_T)\\,. \\] Then, the price of the derivative \\(\\Pi(0;X)\\) at time \\(t = 0\\) must be the price of the portfolio \\(V_0^h\\) to avoid arbitrage opportunities. More specifically, \\[ \\Pi(0;X) = V_0^h \\,. \\] It turns out that to find the price of this portfolio (and hence of the claim), we only need to repeatedly and recursively apply the principles of the one-step binomial model. We illustrate this in a binomial model 2 periods, i.e., \\(T = 2\\). First, we need to introduce further notation. We denote by \\(V_t(k)\\) the value of the replicating portfolio of the claim at the node \\((t,k)\\). Next, we need to split the tree in Figure 7.3 into two (one-period) sub trees as shown in Figures 7.4 and 7.5. Figure 7.4: One-period subtree (up). Figure 7.5: One-period subtree (down). Remark. Note that \\(u^2S_0, udS_0\\) and \\(d^2S_0\\) are the values of \\(S_t\\) and \\(X=\\Phi(S_t)\\). Thus, one have \\(X=\\Phi(u^2S_0), X=\\Phi(udS_0)\\) and \\(X=\\Phi(d^2S_0)\\) (confirm with Figures 7.4 and 7.5). Then, we can apply the principles of the one-period binomial model to compute \\(V_1(1)\\) and \\(V_1(0)\\) as follows \\[\\begin{align*} &amp; V_1(1) = \\frac{1}{(1 +R)}(q_u \\Phi(u^{2} S_0 ) + q_d \\Phi(ud S_0 ) ) \\,, \\\\ &amp; V_1(0) = \\frac{1}{(1 +R)}(q_u \\Phi(u d S_0 ) + q_d \\Phi(d^{2} S_0 ) ) \\,, \\end{align*}\\] where \\(q_u\\) and \\(q_d\\) are the risk neutral probabilities given by \\[\\begin{align*} &amp; q_u = \\frac{(1 +R) - d}{u - d} \\,, \\\\ &amp; q_d = \\frac{u - (1 +R)}{u - d} \\,. \\end{align*}\\] Thus, we now obtain the one-period binomial tree given in Figure 7.6. Figure 7.6: One-period subtree. Please notice that \\(V_1(1)\\) is computed using \\(u^2S_0\\) and \\(udS_0\\). Also, \\(V_1(0)\\) is computed using \\(d^2S_0\\) and \\(udS_0\\). So, it seems natural to compute \\(V_0(0)\\) using the information on \\(V_1(0)\\) and \\(V_1(1)\\). Finally, using this, we compute the initial price of the portfolio \\(V_0(0)\\) as \\[V_0(0) = \\frac{1}{(1 +R)}(q_u V_{1}(1) + q_d V_{1}(0)).\\] Example 7.3 Consider a stock currently with price \\(S_0 = 50\\). The Stock’s price is expected to increase to 10% or decrease 8% during the next two six-month periods. The risk-free interest rate is 5% compounded annually. Compute the price of a 1-year European put option with a strike price of 55. Solution. \\(\\,\\) S0 &lt;- 50 u &lt;- 1.1 d &lt;- 0.92 K &lt;- 55 # Risk-free rate for the period of six months = (1 + r/n)^p - 1, where: r = # risk-free interest rate compounded annually n = compounding periods in a year # (2 semesters = 1 year); n = 2 p = number of compounding periods the rate is # required for (1 semester); p = 1 R &lt;- (1 + 0.05/2)^1 - 1 R ## [1] 0.025 # Number of periods (2 semesters) n &lt;- 2 # Future stock prices: S_t=u^k.d^(t-k).S0 k &lt;- 0:n St &lt;- u^k * d^(n - k) * S0 St ## [1] 42.32 50.60 60.50 # Risk-neutral probabilities qu &lt;- (1 + R - d)/(u - d) qu ## [1] 0.5833 qd &lt;- (u - (1 + R))/(u - d) qd ## [1] 0.4167 # or qd &lt;- 1 - qu # Value of the contingent claim at maturity: X = phi(S_T); T = 2 pmax: parallel # maxima between two vectors Eg: X1=(2,5,7) and X2=(4,0,1). # pmax(X1,X2)=(4,5,7). phi &lt;- pmax(K - St, 0) phi ## [1] 12.68 4.40 0.00 # Note: phi[1] -&gt; k=0 (k is the number of up-moves) phi[2] -&gt; k=1 phi[3] -&gt; k=2 # Price of the option # V_1(0) vu &lt;- (qu * phi[3] + qd * phi[2])/(1 + R) vu ## [1] 1.789 # V_1(1) vd &lt;- (qu * phi[2] + qd * phi[1])/(1 + R) vd ## [1] 7.659 # V_0(0) v0 &lt;- (qu * vu + qd * vd)/(1 + R) v0 ## [1] 4.131 We now give the general binomial algorithm. Proposition 7.1 Consider a claim \\(X = \\Phi(S_T)\\). Then \\(V_t(k)\\) can be computed recursively as \\[\\begin{align*} &amp; V_t(k) = \\frac{1}{(1 +R)}(q_u V_{t + 1}(k+1) + q_d V_{t + 1}(k) ) \\,, \\\\ &amp; V_T(k) = \\Phi(u^{k}d^{T-k} S_0 ) \\,. \\end{align*}\\] In other words, the binomial algorithm consists of the following steps: Generate the tree of stock prices. Calculate the value of the claim at each final node. Calculate the claim values sequentially at each preceding node. To generate the tree of stock prices (step 1.), we can employ the following code: build_tree &lt;- function(S0, u, d, n) { tree &lt;- matrix(0, nrow = n + 1, ncol = n + 1) for (t in 1:(n + 1)) { k &lt;- 0:(t - 1) tree[t, 1:t] &lt;- u^k * d^(t - 1 - k) * S0 } tree } If we consider the same input data as in Example 7.3, we obtain the following tree tree &lt;- build_tree(50, 1.1, 0.92, 2) tree ## [,1] [,2] [,3] ## [1,] 50.00 0.0 0.0 ## [2,] 46.00 55.0 0.0 ## [3,] 42.32 50.6 60.5 # Read the matrix &#39;by rows&#39; and draw the tree. Figure 7.7: Tree for the Example 3.5. With the above tree at hand, we can evaluate the claim at the final nodes (step 2.) by simply taking the last row of the matrix. For instance, # X=Phi(S_T)=max(K-S_T,0) pmax(K - tree[nrow(tree), ], 0) ## [1] 12.68 4.40 0.00 Finally, for the recursive computations (step 3.) we can use the following code: value_bin_mod &lt;- function(qu, R, tree, K) { val_tree &lt;- matrix(0, nrow = nrow(tree), ncol = ncol(tree)) val_tree[nrow(tree), ] &lt;- pmax(K - tree[nrow(tree), ], 0) # European put for (t in (nrow(tree) - 1):1) { for (k in 1:t) { val_tree[t, k] &lt;- ((1 - qu) * val_tree[t + 1, k] + qu * val_tree[t + 1, k + 1])/(1 + R) } } val_tree } Applying the above code to our example we obtain: opt_price &lt;- value_bin_mod(qu, R, tree, K) opt_price ## [,1] [,2] [,3] ## [1,] 4.131 0.000 0 ## [2,] 7.659 1.789 0 ## [3,] 12.680 4.400 0 Note that the price at time \\(t = 0\\) is given by the entry [1, 1], that is, opt_price[1, 1] ## [1] 4.131 Remark. The above code for performing the binomial algorithm was presented using a European put option as an example. However, it can be easily modified to price any other simple derivative. It turns out that Proposition 7.1, implies the following risk-neutral valuation formula. Proposition 7.2 The arbitrage-free price at \\(t = 0\\) of a claim \\(X\\) with maturity \\(T\\) is given by \\[ \\Pi(0;X) = \\frac{1}{(1+R)^T} \\sum_{k = 0}^{T}\\left( \\begin{matrix} T \\\\ k \\end{matrix} \\right) q^k_uq^{T-k}_d \\Phi(S_0 u^k d^{T-k}) \\,. \\] Thus, an alternative solution to Example 7.3 using the above result is the following: pi0 &lt;- sum(choose(n, k) * qu^k * (1 - qu)^(n - k) * phi)/(1 + R)^n pi0 ## [1] 4.131 Remark. Sometimes, instead of \\(u\\) and \\(d\\) a volatility of the stock \\(\\sigma\\) is provided. This stock’s volatility is defined as the annualized standard deviation of the stock return. Luckily, given the volatility \\(\\sigma\\), we can calculate \\(u\\) and \\(d\\) by using \\[u=\\exp(\\sigma/ n) \\quad \\mbox{and} \\quad d=\\exp(-\\sigma/ n) = 1 / u \\,,\\] where \\(n\\) is the number of intervals over one year. One can show that when \\(n\\) tends to infinity, the binomial model converges to the Black-Scholes model (to see ahead). R packages for the binomial model There are some R packages that have implementations for the binomial model. However, only important examples such as call and put options are available. Thus, when dealing with less standard derivatives, the previous analysis is highly relevant. We will come back to more complex examples shortly, but first let us illustrate the use of the derivmkts package (go to RStudio and download package vignettes). library(derivmkts) To compute prices of European (and American) call and put options we make use of the function binomopt(). Let us solve Example 7.3 using this function. We need to note the following about binomopt(): the risk-free rate (r) must be an annual continuously compounded rate (\\(r=r_{continuous}=log(1+R)\\)). To price an European option we need to change the default value of the argument american = TRUE to FALSE. By default, the function works with a volatility, hence we need to use specifyupdn = TRUE to indicate that we will provide \\(u\\) and \\(d\\) through the arguments up and dn. We describe the rest of the arguments needed in the following code: binomopt( s = 50, # Initial stock price k = 55, # Strike price r = log(1 + 0.05), # Continuously-compounded risk-free rate tt = 1, # Time to maturity d = 0, # Dividends, in our case, we do not work with dividends, hence 0. nstep = 2, # Number of periods american = FALSE, # To indicate European putopt = TRUE, # To indicate a Put option specifyupdn = TRUE, # Tells the function to use u and d up = 1.1, # Value of u dn = 0.92 # Value of d ) ## price ## 4.153 Remark. The value 4.153 differs from 4.131 due to the use of a continuously-compounded risk-free rate. Moreover, derivmkts contains the function binomplot() which plots the development of the stock price and shows graphically the probability of being at each node (represented as the area of the circle at that price). The following is the plot for our example: binomplot( s = 50, k = 55, r = log(1 + 0.05), tt = 1, d = 0, nstep = 2, american = FALSE, putopt = TRUE, specifyupdn = TRUE, up = 1.1, dn = 0.92, v = 0, # A value of the volatility must be provided, although not used plotarrows = TRUE, # Plots arrows that connect the nodes of the tree plotvalues = TRUE # Plots the values of the stock prices at each node ) Note that a horizontal line with the strike value is included in the plot. This can also be omitted by using drawstrike = FALSE. Finally, the green and red colors indicate whether or not the option is optimally exercised there (green if yes, red if no). We finish our discussion of the binomial model with the following more complicated example, which cannot be solved directly with the functions in derivmkts. Hence the importance of our early discussion. Example 7.4 A stock price is currently 40. Over each of the next three 5-month periods, it is expected to go up by 10% or down by 5%. The risk-free interest rate is 6% per annum with continuous compounding. Apply Proposition 7.1 and a three-step binomial model to find the value of a European style derivative that pays off \\(X = [\\max(K - S_T, 0)]^3\\), where \\(S_T\\) is the stock price in \\(15\\) months and \\(K = 44\\). Solution. \\(\\,\\) s0 &lt;- 40 u &lt;- 1.1 d &lt;- 0.95 n &lt;- 3 K &lt;- 44 tree &lt;- build_tree(s0, u, d, n) tree ## [,1] [,2] [,3] [,4] ## [1,] 40.00 0.00 0.00 0.00 ## [2,] 38.00 44.00 0.00 0.00 ## [3,] 36.10 41.80 48.40 0.00 ## [4,] 34.29 39.71 45.98 53.24 pmax(K - tree[nrow(tree), ], 0) ## [1] 9.705 4.290 0.000 0.000 R &lt;- exp(0.06 * 5/12) - 1 # Rcont=log(1+R) &lt;=&gt; R=exp(0.06)-1 (annually) =&gt; R=exp(0.06*5/12)-1 for a # 5-month period. R ## [1] 0.02532 qu &lt;- (1 + R - d)/(u - d) qu ## [1] 0.5021 # We cannot use the original function value_bin_mod or package derivmkts!! # X=phi(S_T) is now [max(K-S_T;0)]^3 value_bin_mod.new &lt;- function(qu, R, tree, K) { val_tree &lt;- matrix(0, nrow = nrow(tree), ncol = ncol(tree)) val_tree[nrow(tree), ] &lt;- (pmax(K - tree[nrow(tree), ], 0))^3 # given claim for (t in (nrow(tree) - 1):1) { for (k in 1:t) { val_tree[t, k] &lt;- ((1 - qu) * val_tree[t + 1, k] + qu * val_tree[t + 1, k + 1])/(1 + R) } } val_tree } opt_price &lt;- value_bin_mod.new(qu, R, tree, K) opt_price ## [,1] [,2] [,3] [,4] ## [1,] 132.0 0.00 0 0 ## [2,] 253.1 18.62 0 0 ## [3,] 482.5 38.34 0 0 ## [4,] 914.1 78.95 0 0 Thus, the price of the option is opt_price[1, 1] ## [1] 132 7.3 The Black-Scholes model The binomial model discussed in the previous section is a discrete-time model: the stock price changes at the end of each time period. Another commonly used model for option pricing is the Black-Scholes model, which assumes that the stock price moves continuously on time. The assumptions behind the Black-Scholes model are deep, and in fact, an entire course can be dedicated to the development of this model. In this course, it is sufficient for you to know how to price the options using simulations and the closed-form Black-Scholes formula. We start with a review of the Brownian motion, which will be used to describe the price movements of a stock. 7.3.1 Preliminars: Brownian motion Definition 7.4 (Stochastic process) A stochastic process is a family of random variables \\(\\{X(t), ~t \\in T\\}\\) defined on a probability space \\((\\Omega, \\mathcal{F},P)\\), where: \\(t\\) represents, typically, the time. \\(T\\) is the set where the time parameter \\(t\\) is defined. \\(\\Omega\\) is the set of all possible outcomes. \\(\\mathcal{F}\\) is a set of events. \\(P\\) is a probability function. \\((\\Omega, \\mathcal{F},P)\\) will become clear in ``Probability Theory and Stochastic Processes”. If \\(T=\\mathbb{N}\\), we say that the process is a discrite time process; if \\(T=[a,~b] \\subseteq \\mathbb{R}\\), we say it is a continuous time process. Remark. \\(\\{X(t), ~t \\in T\\}=\\{X(t,\\omega), ~t \\in T, ~ \\omega \\in \\Omega\\}\\). \\(X(t)=X_t\\) is called the sate or position of the process at time \\(t\\). The space of the states, denoted by \\(\\mathcal{S}\\), is the space where the random variables take values. If \\(\\mathcal{S}=\\mathbb{R}\\) the space is called continuous state space. If \\(\\mathcal{S}=\\mathbb{N}\\) the space is called discrete state space. For each fixed \\(\\omega \\in \\Omega\\), the mapping \\(t \\to X(t,\\omega)\\) is called a realization, trajectory or sample path of the process. Definition 7.5 (Standard Brownian motion) A standard Brownian motion (SBM), also known as standard Wiener process, is a stochastic process \\(W = (W(t))_{t \\geq0}\\) satisfying: \\(W(0) = 0\\). The process has independent increments, i.e., for any \\(0 \\leq t_1 &lt; t_2 &lt; \\cdots &lt; t_n\\), \\[W(t_2) - W(t_{1}), \\dots,W(t_n) - W(t_{n-1})\\] are independent random variables. For \\(s &lt; t\\), \\(Y = W(t) - W(s) \\sim N(\\mu_Y = 0, \\sigma^2_Y = t -s)\\). \\(W\\) has continuous trajectories. \\(Cov(W_t,W_s)=min(t,s).\\) Remark. With \\(s=0\\), it follows from 3. that \\(W(t) \\sim N(0,t)\\). Notice that the variance is proportional to the time interval. To generate trajectories of a SBM over a time period \\([0, T]\\), we consider a “small” time increment \\(\\delta t &gt;0\\). Then, consider the independent increments \\[\\begin{align*} &amp; W(\\delta t) - W(0) \\,,\\\\ &amp; W(2\\delta t) - W(\\delta t) \\,,\\\\ &amp; \\ldots \\,. \\end{align*}\\] Note that these increments are \\(N(0, \\delta t)\\) distributed. Moreover, we can compute \\(W(2\\delta t)\\) as \\[ W(2\\delta t) = (W(2\\delta t) - W(\\delta t)) + (W(\\delta t) - W(0)) \\,. \\] Thus, we can repeat the same logic as above to simulate a whole process trajectory. The following code implements this idea: set.seed(12345) delta &lt;- 0.001 # Time increment t &lt;- seq(0, 1, by = delta) # Time interval # rnorm(n, mean = 0, sd = 1) w &lt;- rnorm(n = length(t) - 1, mean = 0, sd = sqrt(delta)) # iid normal distributed r.v.s w &lt;- c(0, cumsum(w)) # Cumulative sum; 0 is the initial value plot(t, w, type = &quot;l&quot;, xlab = &quot;Time&quot;, ylab = &quot;W(t)&quot;, main = &quot;Simulated trajectory of a SBM&quot;, ) We now modify the code above to generate multiple trajectories: nsim &lt;- 100 # Number of simulated trajectories w &lt;- matrix( rnorm(n = nsim*(length(t)-1), mean = 0, sd = sqrt(delta)), nsim, # Each row is one simulated trajectory length(t) - 1 ) w &lt;- cbind(rep(0, nsim), t(apply(w, 1, cumsum))) # matrix with trajectories plot(t, w[1, ], # Plots the first trajectory type = &quot;l&quot;, ylim = c(-3.5, 3.5), xlab = &quot;Time&quot;, ylab = &quot;W(t)&quot;, main = &quot;Simulation of SBM&quot; ) apply(w[-1, ], 1, function(x, t) lines(t, x), t = t) # Plots the remaining trajectories The standard Brownian motion can be generalized to the arithmetic Brownian motion, which scales and shifts the former. More specifically, \\(X(t)\\) is an arithmetic Brownian motion if \\[X(t) = \\mu t + \\sigma W(t),\\] where \\(W(t)\\) is a standard Brownian motion, \\(\\mu \\in \\mathbb{R}\\) and \\(\\sigma \\in \\mathbb{R}^+\\). Moreover, note that for \\(s &lt; t\\), \\[X(t)-X(s)\\sim N(\\mu (t - s), \\sigma^2(t - s)).\\] To simulate from a standard Brownian motion an easier way is to modify in our code above and generate independent \\(N(\\mu \\delta t, \\sigma^2\\delta t)\\) random variables. The following code implements the simulation: first we simulate data: mu &lt;- -1 sigma2 &lt;- 0.5 nsim &lt;- 100 x &lt;- matrix(rnorm(n = nsim * (length(t) - 1), mean = mu * delta, sd = sqrt(delta * sigma2)), nsim, length(t) - 1) x &lt;- cbind(rep(0, nsim), t(apply(x, 1, cumsum))) secondly, we plot data: plot(t, x[1, ], type = &quot;l&quot;, ylim = c(-3, 2), xlab = &quot;Time&quot;, ylab = &quot;X(t)&quot;, main = &quot;Simulation of arithmetic Brownian motion&quot; ) apply(x[-1, ], 1, function(x, t) lines(t, x), t = t) Experiment with different \\(\\mu\\) and \\(\\sigma^2\\) values: mu &lt;- 2 sigma2 &lt;- 0.2 nsim &lt;- 100 x &lt;- matrix( rnorm(n = nsim * (length(t) - 1), mean = mu * delta, sd = sqrt(delta * sigma2)), nsim, length(t) - 1 ) x &lt;- cbind(rep(0, nsim), t(apply(x, 1, cumsum))) plot(t, x[1, ], type = &quot;l&quot;, ylim = c(-1, 3), xlab = &quot;Time&quot;, ylab = &quot;X(t)&quot;, main = &quot;Simulation of arithmetic Brownian motion&quot; ) apply(x[-1, ], 1, function(x, t) lines(t, x), t = t) Note that the arithmetic Brownian motion can take negative values. Hence, using it for modeling stock prices is questionable. Instead, we now introduce the so-called called geometric Brownian motion, which can only take non-negative values. More precisely, a geometric Brownian motion, denoted by \\(S(t)\\), is a stochastic process of the form \\[S(t) = S(0)\\exp \\left( X(t) \\right) = S(0)\\exp \\left( \\mu t + \\sigma W(t) \\right),\\] where \\(S(0)&gt;0\\) is some known starting value, and \\(X(t)\\) is an arithmetic Brownian motion. The following code generates some trajectories of this process using the previous implementation: s0 &lt;- 2 s &lt;- s0 * exp(x) plot(t, s[1, ], type = &quot;l&quot;, ylim = c(0, 40), xlab = &quot;Time&quot;, ylab = &quot;S(t)&quot;, main = &quot;Simulation of geometric Brownian motion&quot; ) apply(s[-1, ], 1, function(x, t) lines(t, x), t = t) Note that in particular, \\[\\dfrac{S(t)}{S(0)}\\sim LN(\\mu t, \\sigma^2 t),\\] and more generally, for \\(s &lt; t\\), \\[\\dfrac{S(t)}{S(s)}\\sim LN(\\mu (t - s), \\sigma^2(t - s)).\\] Remember: \\(Y \\sim LN(.,.) \\iff \\log(Y) \\sim N(.,.).\\) Finally, one can show (to see next year!) that a geometric Brownian motion of the form \\[S(t) = S_0\\exp \\left( \\left( \\mu - \\frac{\\sigma^2}{2}\\right) t + \\sigma W(t) \\right) \\,,\\] satisfies the stochastic differential equation (SDE) \\[ dS(t) = \\mu S(t) dt + \\sigma S(t)dW(t), \\quad S(0)=S_0 \\,, \\] known as the Black-Scholes model. 7.3.2 The Black-Scholes formula As in the binomial model, the Black–Scholes model assumes that the prices of these two assets satisfy \\[\\begin{align} &amp; dB(t) = r B(t) dt \\,, \\nonumber \\\\ &amp; dS(t) = r S(t) dt + \\sigma S(t) d\\overline{W}(t), \\quad S(0)=S_0 \\,,\\tag{7.1} \\end{align}\\] where \\(B(t)\\) represents the deterministic price of a riskless asset (a bond or a bank deposit); \\(S(t)\\) is the stochastic price process of a risky asset (a stock or an index); \\(\\overline{W}\\) is a standard Brownian motion with respect to the original probability measure \\(P\\); \\(r\\) is the risk-free interest rate; \\(\\sigma\\) represents the volatility of the risky asset, and \\(S_0\\) is the (known) initial condition. The solution of (7.1) is the geometric Brownian motion: \\[S(t) = S_0\\exp \\left( \\left( r - \\frac{\\sigma^2}{2}\\right) t + \\sigma \\overline{W}(t) \\right).\\] Now, we consider a contingent claim (a financial derivative) of the form \\[X = \\Phi(S(T)) \\,.\\] It can be shown that the arbitrage-free price \\(\\Pi(0;X)\\) of \\(X\\) is given by the risk-neutral evaluation formula \\[\\begin{equation} \\Pi(0;X) = e^{- r T} \\mathbb{E}^{Q}\\left[ \\Phi(S(T)) \\right] \\,, \\tag{7.2} \\end{equation}\\] where the behavior of \\(S\\) under \\(Q\\) is described by the SDE \\[ dS(t) = r S(t) dt + \\sigma S(t)dW(t) \\,, \\] whose solution is the geometric Brownian motion and where \\(W(t)\\) denotes the Brownian motion under the measure \\(Q\\). In particular, we have that \\(S(T)\\) is explicit and given by \\[\\begin{equation} S(T) = S_0\\exp \\left( \\left( r - \\frac{\\sigma^2}{2}\\right) T + \\sigma W(T) \\right). \\tag{7.3} \\end{equation}\\] When considering a European call option, that is, \\(\\Phi(x) = \\max(x - K, 0)\\), (7.2) and (7.3) lead to the famous Black–Scholes formula as follows: Proposition 7.3 (Black-Scholes formula) The price of an European call option \\(C(0)\\) with strike price \\(K\\) and time of maturity \\(T\\) is given by \\[\\begin{equation} C(0) = S_0 N(d_1) - K e^{-rT}N(d_2) \\,, \\tag{7.4} \\end{equation}\\] where N is the cumulative distribution function for the \\(N(0, 1)\\) distribution and \\[\\begin{align*} &amp; d_1 = \\frac{1}{\\sigma \\sqrt{T}}\\left( \\log\\left(\\frac{S_0}{K}\\right) + \\left( r + \\frac{1}{2} \\sigma^2 \\right) T \\right) \\,,\\\\ &amp; d_2 = d_1 - \\sigma \\sqrt{T} \\,. \\end{align*}\\] Similarly, the price of a European put option \\(P(0)\\) with strike price \\(K\\) and time of maturity \\(T\\) is given by \\[ P(0) = K e^{-rT}N(-d_2) - S(0) N(-d_1) \\,, \\] with \\(d_1\\) and \\(d_2\\) as above. \\(N(d_1)\\) and \\(N(d_2)\\) are obtained in R as and . Remark. Using Itô’s formula (next year, stochastic calculus), one can get an expression for the BS formula as a PDE (already seen in MMF – Part I). In R, the Black–Scholes formula to price European call and put option is available in the derivmkts package under the functions bscall() and bsput(), respectively. We illustrate its use with an example. Example 7.5 Consider a European call option over a stock with a current price S(0) = 50 and volatility 0.25. Moreover, the risk-free interest rate with continuous compounding is 6% per annum, the strike price is 45, and the option’s time to maturity is 6 months. Find the price of the option. Solution. \\(\\,\\) # bscall(s, k, v, r, tt, d) s: Price of the underlying asset k: Strike price v: # Volatility of the asset price, defined as the annualized standard deviation # of the continuously-compounded return r: Annual continuously-compounded # risk-free interest rate tt: Time to maturity in years d: Dividend yield, # annualized, continuously-compounded s &lt;- 50 k &lt;- 45 v &lt;- 0.25 r &lt;- 0.06 tt &lt;- 6/12 d &lt;- 0 # No dividends bscall(s, k, v, r, tt, d) ## [1] 7.382 7.3.3 Greeks Greeks represent sensitivities of a derivative value to changes in the underlying parameters used to determine its price. More specifically, if we denote by \\(V\\) be the price of a derivative, which depends on the underlying stock price \\(S\\), a risk-free rate \\(r\\), a volatility \\(\\sigma\\) and with maturity \\(T\\), then the Greeks are defined as follows: Definition 7.6 (Greeks) \\(\\,\\) Delta, \\(\\Delta\\): Measures the rate of change of the option price with respect to changes in the underlying stock price. [similar to velocity] \\[\\Delta=\\frac{\\partial V}{\\partial S}\\,.\\] Gamma, \\(\\Gamma\\): Measures the rate of change in \\(\\Delta\\) with respect to changes in the underlying stock price. [similar to acceleration] \\[\\Gamma=\\frac{\\partial^2 V}{\\partial S^2}=\\frac{\\partial \\Delta}{\\partial S}\\,.\\] Vega, \\(\\nu\\): Measures sensitivity with respect to changes in the volatility \\(\\sigma\\). \\[\\nu = \\frac{\\partial V}{\\partial \\sigma}\\,.\\] Rho, \\(\\rho\\): Measures sensitivity with respect to changes in the risk-free interest rate. \\[\\rho=\\frac{\\partial V}{\\partial r}\\,.\\] Theta, \\(\\Theta\\): Measures the sensitivity of the value of the derivative to the passage of time. [Theta is generally expressed as a negative number and can be thought of as the amount by which an option’s value declines every day.] \\[\\Theta=-\\frac{\\partial V}{\\partial T }\\,.\\] Elasticity or Lambda, \\(\\lambda\\): Is the percentage change in option value per percentage change in the underlying price (a measure of leverage). \\[\\lambda=\\frac{\\partial V}{\\partial S} \\frac{S}{V}=\\Delta \\times \\frac{S}{V}\\,.\\] Psi, \\(\\psi\\): Is the percentage change in option value per percentage change in the underlying dividend yield (\\(q\\)). \\[\\psi =\\frac {\\partial V}{\\partial q}\\,.\\] In particular, for a European call option with strike price \\(K\\) and time of maturity \\(T\\) we have the following explicit expressions: \\[\\begin{align*} &amp;\\Delta=N(d_1)\\,, \\\\ &amp;\\Gamma=\\frac{N^\\prime(d_1)}{S\\sigma \\sqrt{T}}\\,,\\\\ &amp;\\nu =S\\sqrt{T}N^\\prime(d_1) \\,, \\\\ &amp;\\rho=KTe^{-rT}N(d_2)\\,, \\\\ &amp;\\Theta=-\\frac{S(0)N^\\prime(d_1)\\sigma}{2\\sqrt{T}}-rKe^{-rT}N(d_2)\\,. \\end{align*}\\] The derivmkts R package allows us to compute the Greeks for a financial derivative via the function greeks(). For instance, the Greeks for the option in Example 7.5 can be computed as follows: greeks(bscall(s, k, v, r, tt, d = 0)) ## bscall ## Premium 7.38194 ## Delta 0.80348 ## Gamma 0.03134 ## Vega 0.09794 ## Rho 0.16396 ## Theta -0.01210 ## Psi -0.20087 ## Elasticity 5.44217 Furthermore, greeks() accepts vector inputs, which in particular allow us to visualize the Greeks. s &lt;- seq(0.5, 80, by = 0.5) call_greeks &lt;- greeks(bscall(s, k, v, r, tt, d = 0)) for (i in rownames(call_greeks)) { plot(s, call_greeks[i, ], main = paste(i), ylab = i, type = &quot;l&quot;, col = &quot;blue&quot;) } "],["exercises.html", "8 Exercises 8.1 Related to Chapters 1 to 6 8.2 Related to Chapter 7", " 8 Exercises 8.1 Related to Chapters 1 to 6 1. Write an R code to determine the result of the following computation: \\[ e^{\\pi}\\left( \\log_2(10) + \\frac{5^2 + \\sin(8)}{\\sqrt{2}}\\right)^{-3} \\,. \\] 2. Without using R, determine the result of the following logical computation ((!(4 == 3) | (abs(-3) &lt;= 2)) &amp; ((2^2 &gt; 4) &amp; (TRUE))) | ((!FALSE | (4+2) == 5) &amp; (0.5 &gt;= (1/2))) Verify your result by typing the code in R. 3. Find the errors in the following lines of code: \\(\\,\\) 2 + 3 *4 + sqrt[100] \\(\\,\\) (2 + i) / 3 + {1e1 + 4.0i} \\(\\,\\) time.To.Maturity &lt;- 6 Interest.rate &lt;- 0.05 {1e-0 + interest.rate}^{-time.To.Maturity} 4. Without using R, determine the result of the following computation: x &lt;- c(1, 2, 3) x[2] / x[2]^2 - 1 + 3 * x[3] - x[2 - 1] Verify your result by typing the code in R. 5. Write an R code to calculate the amount of money owed after \\(n\\) years, where \\(n\\) varies from \\(1\\) to \\(10\\) in yearly increments, assuming that the money lent originally is \\(2350\\) and the interest rate remains constant throughout the period at \\(5\\%\\). 6. Consider the vector 1:N, where N is a positive integer. Write an R code that determines how many elements in the vector are exactly divisible by \\(4\\). Test your code with N &lt;- 40. 7. Compute the mean of: \\(v=(0, 1, NA, 2, 7).\\) \\(u=(-Inf, 0, 1, NA, 2, 7, Inf).\\) 8. Create: a vector with values \\(e^x\\cos(x)\\) at \\(x=3, 3.1, 3.2, \\ldots, 6.\\) a vector with values \\(\\left(2,\\frac{2^2}{2},\\frac{2^3}{3}, \\ldots, \\frac{2^{25}}{25}\\right).\\) 9. Compute: \\[\\sum_{j=10}^{100}{j^3+4j^2}.\\] \\[\\sum_{j=1}^{25}{\\frac{2^j}{j}+\\frac{3^j}{j^2}}.\\] 10. Create the vectors: \\((1,2,3,\\ldots,19,20)\\). \\((20,19,\\ldots,2,1)\\). \\((1,2,3,\\ldots,19,20,19,18,\\ldots,2,1)\\). \\((1,2,3, 1,2,3,\\ldots,1,2,3)\\) where there are 10 occurrences of 1. \\((1,1,\\ldots,1, 2,2,\\ldots,2, 3,3,\\ldots,3)\\) where there are 10 occurrences of 1, 20 occurrences of 2 and 30 occurrences of 3. \\((0.1^30.2^1,0.1^60.2^4,\\ldots,0.1^{36}0.2^{34})\\). 11. Use the function paste to create the following character vector of length 20: \\[ \\left(\\text{&quot;label 1&quot;},\\text{&quot;label 2&quot;},\\ldots,\\text{&quot;label 20&quot;}\\right) \\] 12. Set the vector v2 equal to the following: “A” “A” “B” “B” “C” “C” “D” “D” “E” “E” (note the letters are all uppercase). 13. Set the vector v3 equal to the following: “a” “b” “c” “d” “e” “a” “b” “c” “d” “e” (note the letters are all lowercase). 14. Set the vector v4 equal to the words “dog” 10 times, “cat” 9 times, “fish” 6 times, and “fox” 1 time. 15. Run the following lines: &gt; set.seed(50) &gt; x &lt;- sample(0:999, 250, replace = TRUE) &gt; y &lt;- sample(0:999, 250, replace = TRUE) Explain the meaning of x and y. Denote by \\(x_i\\) and \\(y_i\\) the entries of the vectors \\(x\\) and \\(y\\), respectively. Create vectors \\((y_2-x_1,\\ldots,y_n-x_{n-1})\\) and \\(\\left(\\frac{\\sin(y_1)}{\\cos(x_2)},\\ldots,\\frac{\\sin(y_{n-1})}{\\cos(x_n)}\\right).\\) Compute \\[ \\sum_{i=1}^{n-1}\\frac{e^{-x_{i+1}}}{x_i+10}.\\] Denote by \\(\\overline{x}\\) the mean of the vector \\(x\\) and compute \\[\\sum_{i=1}^n|x_i-\\bar{x}|^{1/2}.\\] Extract the values of \\(x\\) which correspond to the values of \\(y\\) which are \\(&gt; 500\\). How many values of \\(x\\) are above the mean of \\(y\\)? How many values of \\(x\\) are smaller than the minimum value of \\(y\\)? How many values of \\(x\\) are divisible by \\(2\\)? Extract the 1st minimum value of \\(x\\), the 4th minimum value of \\(x\\), the 7th minimum value of \\(x\\), etc. 16. Create a random sequence of length 100 taking values “low”, “medium” and “high”. Consult the help of sample. 17. Create a vector containing the following student grades: 70, 80, 55, 67, 90, 92, 83, 74, 100, 87, 49. Using logical operators and vector functions, answer the following question: What is the average grade of the whole group? How many students have grades less than 65? What is the average grade of those students with grades between 60 and 80 (including 60 and 80)? Assume that we add three new students with grades 65, 98, 54. Repeat questions a)-c) with the new vector of grades. 18. Write an R program to compute the alternating harmonic series \\[ 1 - \\frac{1}{2} + \\frac{1}{3} - \\frac{1}{4} + \\cdots = \\sum_{n = 1}^{\\infty } \\frac{(-1)^{n-1}}{n} \\,, \\] up to a finite number of summands \\(N\\). Test your code with \\(N = 100\\) and compare with \\(\\log(2)\\). 19. The function cov() computer the sample covariance of two vectors. Recall that for two vectors \\(\\mathbf{x} = (x_1, \\dots, x_n)\\) and \\(\\mathbf{y} = (y_1, \\dots, y_n)\\) the sample covariance is given by \\[ \\mbox{Cov}(\\mathbf{x}, \\mathbf{y}) = \\frac{1}{n-1} \\sum_{i = 1}^{n} (x_i - \\bar{x})(y_i - \\bar{y}) \\] Write an R program to compute the sample correlation without using the cov() function. Test your code with the following vectors: x &lt;- c(1, 2, 3, 4) and y &lt;- c(2, 2, 3, 5). Verify your result using cov(x, y). 20. Create three vectors of length 3, with content and names of your choice. Next, combine the three vectors into a \\(3 \\times 3\\) matrix where each column represents one of your vectors. Finally, compute the determinant (det() - is your matrix invertible?) and the transpose of your matrix. 21. Consider the following matrix: matrix(c(c(-4, 2, 1), c(0, -1, 0.5), c(1.5, 0.2, -2)), ncol = 3, byrow = TRUE) ## [,1] [,2] [,3] ## [1,] -4.0 2.0 1.0 ## [2,] 0.0 -1.0 0.5 ## [3,] 1.5 0.2 -2.0 Compute the sum of rows (that is, you have to return a vector of length three with first entry -1) via the following three methods: Using the rowSums() function (see help for more information). Using the apply() function. Using matrix multiplication. Hint: This can be done by multiplying the above matrix with an appropriate vector. 22. Write an R program to: Create a numeric vector called rates with values: 0.043, 0.045, 0.041, 0.049, 0.05, 0.055, 0.048, 0.0495, 0.051, 0.044, 0.045, 0.0455. Create a character vector called months with values: “Jan”, “Feb”, “Mar”, “Apr”, “May”, “Jun”, “Jul”, “Aug”, “Sep”, “Oct”, “Nov”, “Dec”. Create a data frame called monthly_rates using months and rates. Add a new column to your data frame called year with values 2021 for all rows. Extract the rows where the rates are above 5%. Extract the rows where the rates are below the mean of the whole year. 23. Assume a group of students with ages age &lt;- c(19, 20, 18, 19, 18, 20, 18, 19, 19, 20) and grades grade &lt;- c(90, 75, 80, 87, 74, 93, 100, 66, 71, 89) Let us imagine that we want to compute the average grade by age. We can use the tapply() function to do so. Look at the documentation of tapply() (?tapply) and solve the above problem. 24. Consider the matrix \\[A = \\begin{bmatrix} 1 &amp; 1 &amp; 3 \\\\ 5 &amp; 2 &amp; 6 \\\\ -2 &amp; -1 &amp; -3 \\end{bmatrix}\\] Verify that \\(A^3=0\\). Replace the third column by the sum of column 1 and column 2. 25. Consider the matrix \\[ M = \\begin{bmatrix} 33 &amp; 51 &amp; 60 \\\\[0.3em] 20 &amp; 35 &amp; 17 \\\\[0.3em] 15 &amp; 27 &amp; 24 \\\\[0.3em] 15 &amp; 21 &amp; 28 \\\\[0.3em] 14 &amp; 25 &amp; 29 \\\\[0.3em] 10 &amp; 53 &amp; 24 \\\\[0.3em] \\end{bmatrix},\\] and replace even numbers by \\(-1\\). 26. Solve the linear system \\[\\begin{cases} 2y+x-z=1\\\\ 2z-x-y=0\\\\ x+1+y+2z=1 \\end{cases}\\] 27. Run the following lines: &gt; set.seed(75) &gt; M &lt;- matrix(sample(10, size = 60, replace = TRUE), nrow = 6) Explain the output. Find the number of entries in each row which are greater than 4. Which rows contain exactly two occurrences of the number 7? Denote by \\(M_{i,j}\\) the entries of the \\(n\\times m\\) matrix \\(M\\) and compute the following means and sums of squares: \\[\\begin{align*} \\mu&amp;=\\frac{1}{n\\times m}\\sum_{i,j}M_{i,j}\\\\ \\mu_i&amp;=\\frac{1}{m}\\sum_{j}M_{i,j},\\quad i=1,\\ldots,n\\\\ SS_1&amp;=\\sum_i (\\mu-\\mu_i)^2\\\\ SS_2&amp;=\\sum_{i,j}(M_{i,j}-\\mu_i)^2\\\\ SS_3&amp;=\\sum_{i,j}(M_{i,j}-\\mu)^2 \\end{align*}\\] 28. Install and load the package DAAG. Execute: Type library(help=\"DAAG\") to get the information on this package. Consider the dataset carpriceand apply the convenient R command to check the structure of the dataset. Set a name for carprice, say x. Explain the meaning of table(x$Type). Replace all column names. Compute the mean, variance, standard deviation, range, maximum and minimum of the maximum price variable. Drop all the rows with maximum price higher than 24.8 m.u. Drop all the rows with minimum price lower than 14.0 m.u. 29. Create a list with information about 3 workers as follows: The list should have 4 vectors as components: name, age, gender and a boolean variable (it assumes values 0 or 1 that defines whether the person works or not). Create a data frame with the information from the previous list. Add a vector to the previous data frame with information about the person’s job. Compute the mean, variance, standard deviation, range, maximum and minimum of the age. 30. Run the following lines: &gt; set.seed(75) &gt; x &lt;- sample(10, size = 10, replace = TRUE) &gt; y &lt;- sample(10, size = 10, replace = TRUE) Create a list whose elements are the vectors \\(x\\) and \\(y\\) with names “sample1” and “sample2”, respectively. Create a list with the mean and standard deviation of each sample. 31. Create a list: with years from 2005 to 2016, 12 months and 31 days. replace year by c(2000:2010). delete the value 4 of the month. 32. Write a function called my_add that adds two numbers (x and y) together and returns the results. Run my_add(5,7). 33. Copy the function my_add above and add an error message that returns “x and y must be numbers” if x or y are not both numbers. 34. Write a function that accepts a numerical vector \\((x_1,x_2,\\ldots,x_n)\\) as argument and returns the vector \\[\\left(x_1,\\frac{x_2^2}{2},\\ldots,\\frac{x_n^n}{n}\\right).\\] Run for 1:4. Write a function that accepts a single number \\(x\\) and a positive integer \\(n\\) and returns the sum \\[1+x+\\frac{x^2}{2}+\\frac{x^3}{3}+\\cdots+\\frac{x^n}{n}.\\] Run for \\(x=\\sqrt{2}\\) and \\(n=5\\). Write a function which takes a matrix as single argument and returns a matrix which is the same as the function argument but every odd entry is doubled. Run for matrix(sample(1:10),2,5). Write a function to convert the temperature measured in Celsius (°C) to Fahrenheit (°F). Check that f.d(0) = 32 and f.d(-40) = -40. Write a function that takes a single integer argument \\(n\\) and returns the sum of its divisors, e.g., if \\(n=6\\), then the function returns \\(1+2+3+6\\). Write a function that takes arguments \\(a,b,c\\in\\mathbb{R}\\) and returns the roots of the polynomial \\(ax^2+bx+c\\). The output should be a list containing the two roots. In case the roots are complex conjugated, the output of each root should be a list of its real and imaginary parts. Find the solutions of \\(x^2-4x+4=0\\) and \\(3x^2-x+4=0\\). 35. Consider the function \\[ f(x)=\\begin{cases} 2e^{-2x}, &amp; x \\geq 0 \\\\ 0, &amp; x&lt;0 \\end{cases}. \\] Show that \\(f\\) is a density probability function (dpf). Let \\(X\\) be a r.v. with dpf \\(f\\) and compute \\(P(X&gt;1)\\). Show the value with 2 decimal places. Compute \\(P(0.3&lt;X&lt;0.7)\\). Show the value with 3 decimal places. Compute \\(E[X]\\). Show the value with 1 decimal place. 36. Plot a graphic of \\(f(x)=1-\\frac{1}{x}sin(x)\\) for \\(0&lt;x&lt;5\\) and for \\(0&lt;x&lt;50\\). 37. Consider a random variable \\(X\\) with probability density function (pdf) \\[ f_X(x)=\\frac{x}{4}e^{-\\frac{x^2}{8}},\\,\\,\\,x\\geq 0 \\] Write an R function to compute the above pdf. Check whether this function is indeed a pdf (i.e., that it integrates 1) by: A sum approximation of the form \\(\\sum f(x_i) \\Delta(x)\\), where \\(\\Delta(x)\\) is a “small” increment. Hint: create a sequence vector (over a relatively large interval and with a small increment), evaluate your function in a) on the sequence vector, multiply the evaluation by the increment and finally sum. Using the integrate(f, lower, upper) function. Note: $value gives the value of the integral. Compute the expected value and the variance of \\(X\\). Modify your function in a) so that an error message is displayed if a negative value is given as input. 38. We know that \\[ 1 + \\frac{1}{2} + \\frac{1}{4} + \\frac{1}{8} + \\cdots = \\sum_{n=0}^{\\infty} \\frac{1}{2^n} = 2 \\,. \\] Using a while loop, find a value \\(N\\) such that \\[ 2 - \\sum_{n=0}^{N} \\frac{1}{2^n} \\leq \\epsilon \\,, \\] where \\(\\epsilon = 0.00001\\). 39. Write a function that performs the inner product of two vectors using for loops. Using microbenchmark() compare the performance of your implementation with the inner product using the %*% operator. Try with large vectors, let’s say length 100, and times = 10000. 40. Consider the data set “EuStockMarkets” in R corresponding to the “Daily Closing Prices of Major European Stock Indices, 1991-1998”. Write an R program to plot a histogram of “DAX”. Note: to access “DAX” use EuStockMarkets[, 1]. Compute the log-returns of “DAX”. Recall that the log-returns are computed as \\[ \\log(P_t/P_{t-1}) \\,, \\] where \\(P_t\\) are the closing prices. Compute the mean and standard deviation of the log-returns. Plot a histogram of the log-returns. In your plot in d), add the density function of a normal distributed random variable with mean and standard deviation the values computed in c). Plot “DAX” versus “SMI” and compute their correlation. 41. Let \\(X\\) be a normal random variable with mean \\(2\\) and variance \\(9\\), that is, \\(X\\sim\\mathcal{N}(2,9)\\). Compute: \\(\\mathbb{P}(|X|\\leq 2.4)\\). The 95% quantile of the given distribution. 42. Consider the cars data set in R. Compute the correlation between speed and dist, and create a scatter plot to compare speed vs dist. Do you see any relationship? Fit a linear regression model to explain distance in terms of speed. Add the regression line to your plot in a). Hint: this can be done using the abline() function applied to your regression model in b). Predict dist for values of speed of 28 and 30. Does the model seem to satisfy the assumptions of mean zero, constant variance, and normality for the residuals? 8.2 Related to Chapter 7 43. A stock price is currently 20. It is known that at the end of 1 year it will go up by 10% or down by 5%. The risk-free interest rate is 8% per annum with annual compounding. Write the R code to find the initial value of a 1-year European put option with a strike of 20. 44. A stock price is currently 40. It is known that at the end of 9 months, it will either be 45 or 35. The risk-free interest rate with continuous compounding is 10% per annum. Write the R code to find the initial value of a 9-month European call option on the stock with an exercise price of 40. Describe the hedging portfolio for the option. 45. A stock price is currently 30. Over each of the next two 4-month periods, it is expected to go up by 8% or down by 10%. The risk-free interest rate is 12% per annum with quarterly compounding. Write an R code to find the initial value of an 8-month European call option with a strike price of 34. 46. A stock price is currently 100. During each three-month period for the next six months, it will increase by 10% or decrease by 10%. The risk-free interest rate is 8% per annum with quarterly compounding. Write an R program that gives the binomial tree evolution of the stock price. Write an R code to find the initial value of a six-month European put option with strike K = 105. 47. A stock is currently priced at 30. Over each of the next two 2-month periods, it is expected to increase by 8% or decrease by 10%. The risk-free interest rate is 10% per annum with continuous compounding. What is the initial value of a 4-month derivative with strike \\(K = 30\\) and that pays off \\(X = \\max(S_T^2 -K,0)\\), where \\(S_T\\) is the stock price in four months? 48. A stock price is currently 40. In two months, it will either be 42 or 38, and during this period, the risk-free interest rate is 6% per annum with monthly compounding. If it rises to 42 in two months, then it will either be 48 or 40 after another two months. If it drops to 38 after the first two months, then after another two months, it will either be 42 or 34. The risk-free interest rate is 10% per annum with monthly compounding during the second two-month period. Write an R program to calculate the initial value of a derivative that pays off \\(\\frac{1}{2}\\left(\\max(44 - S_T, 0 )\\right)^2\\), where \\(S_T\\) is the stock price in four months. 49. It is known that for any \\(a \\in \\mathbb{R}\\), the standard Brownian motion satisfies that \\(W(t) &gt; a\\) with probability 1 for some \\(t&gt;0\\). Note that in the lecture notes, we simulated a standard BM over a fixed time period \\(T\\). In this exercise, we let the time vary, and we fix a threshold \\(a &gt;0\\), then simulate a standard BM until it reaches the given threshold. Write an R program to plot one trajectory of a standard Brownian motion until it reaches \\(a = 1\\). Hint: Use a while loop to generate normal distributed increments until the condition is satisfied. 50. Via simulations, approximate the probability that an arithmetic Brownian motion with drift 0.5 and volatility 0.1 is above 1 at time 2. Compare your result with the theoretical probability. 51. Consider a European put option on a non-dividend-paying stock with current price is 40. The strike price is 38, the risk-free interest rate is 12% per annum with continuous compounding, the volatility is 30% per annum, and the time to maturity is three months: Find the price of the option using the BS formula. Approximate the price of the option using simulations (10000). Approximate the option’s price using a binomial model with 1000 steps. 52. A stock has current price \\(S(0) = 1416\\). What is the value of an 8-month European call option on that stock with a strike price of \\(1450\\) if the volatility is 0.42 and the risk-free interest rate is 5% per annum with continuous compounding? Find the greeks for the corresponding option. Plot vega again the initial stock price \\(S(0)\\) ranging from 0.5 to 2000.   Copyright: All rights reserved. No parts of the content of this website may be reproduced or distributed without the prior written permission of the author. Without prior written permission, it is not permitted to copy, download or reproduce the text, code, and images in any way whatsoever. 2024 \\(|\\) Nuno M. Brites \\(|\\) nbrites@iseg.ulisboa.pt   "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
